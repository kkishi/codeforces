# 典型要素

* 調和級数の和はnlogn
* 累積和
* 主客転倒

# 解説

* [公式](https://codeforces.com/blog/entry/94216)
* https://twitter.com/m_99kyopro/status/1430215454581157888
* https://twitter.com/Enjapma_kyopro/status/1430214729272684547
* https://twitter.com/butsurizuki/status/1430215076208775168
* https://twitter.com/se1_ka4/status/1430215444581937161


# 解法

`f(i) = i番目のcellから出発して1番目のcellにたどり着く方法の数`を考える。D1と逆方向であることに注意。  
`S(x) = xから操作の結果たどり着く先の多重集合`とする。これは説明の便宜上導入するもので、実際にはそれぞれのxについて`f(x) = Σf(e) where e∈S(x)`を管理する。

`Sub(x) = S(x)のうちSubtractionを使ったもの`、`Dib(x) = S(x)のうちFloored divisionを使ったもの`とする。具体的には:

Sub:
* Sub(2) = {1}
* Sub(3) = {1, 2}
* Sub(4) = {1, 2, 3}
* Sub(5) = {1, 2, 3, 4}
* Sub(6) = {1, 2, 3, 4, 5}
* Sub(7) = {1, 2, 3, 4, 5, 6}
* Sub(8) = {1, 2, 3, 4, 5, 6, 7}

Div:
* Div(2) = {1}
* Div(3) = {1, 1}
* Div(4) = {2, 1, 1}
* Div(5) = {2, 1, 1, 1}
* Div(6) = {3, 2, 1, 1, 1}
* Div(7) = {3, 2, 1, 1, 1, 1}
* Div(8) = {4, 2, 2, 1, 1, 1, 1}

これらの集合が、xが増加するたびにどのように変化するかに着目することで、いわゆるimos法を用いて計算できる。
Subについては簡単で、`Diff[x+1] += S(x)`とすれば良い。
Divについては、天下り的だが、xの約数に関係していることを利用する。例えば8の約数は1,2,4なので、以下が起きる:

* 0が1になる: Diff[8] += -S(0) + S(1)
* 1が2になる: Diff[8] += -S(1) + S(2)
* 3が4になる: Diff[8] += -S(3) + S(4)

さらにこれは、約数に注目してその倍数を更新することで、O(nlong)のDPになる。例えばS(2)が分かった時点で以下ができる:

* Diff[4] += -S(1) + S(2)
* Diff[6] += -S(1) + S(2)
* Diff[8] += -S(1) + S(2)
